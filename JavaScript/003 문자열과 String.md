# ✍️ What I learned Today ?

---
## ✨ Let's go 자바스크립트 ! 

### 003. 문자열과 String 그리고 연산자

* Summary
1. 래핑
2. 문자열을 배열로 읽고쓰기
3. 논리연산자 관계연산자

---

| 💡 짚고 넘어가기 |
- 문자열과 String은 다른 개념이다. 문자열은 원시타입 데이터이고, String은 객체다.
자바의 String과는 다르다!

- 문자열 처리 : 
  - +연산자는 피연산자가 모두 문자열이면 문자열로 연결
  - 피연산자 중 하나가 문자열 또는 문자열로 변환할 수 있는 객체이면 다른 연산자의 타입을 문자열로 바꾼 다음 연결. 그렇지 않으면 피연산자 두개를 `숫자` 또는 `NaN`으로 타입을 바꾸어 더한다.

---

#### 1.래핑 
문자열을 String 객체로 변환하려면 String 생성자를 사용한다. 그리고 이 행위를 `래핑` 이라고 한다. 

잘 생각해보자. 여태까지 어떤 문자열의 길이를 구할때 어떻게 했지?
```js
let a = "amuro";
a.length;
```
이렇게 원시값이 든 변수에 그대로 length 프로퍼티로 구했는데? 문자열은 객체가 아니므로 프로퍼티를 가지고 있지 않다. 그러면 어떻게? HOW?

★ 문자열에서 프로퍼티를 사용하려고 하면 문자열이 자동으로 String 객체로 변환되기 때문에 가능하다!

위와 같은 코드를 실행했을때, 자바스크립트 내부적으로 문자열 a를 String 객체로 변환하여 메소드를 사용하는 것이다. 그리고 처리가 끝나면 곧바로 메모리에서 삭제된다. 이러한 객체를 가르켜 `래퍼객체` 라고 한다. 

      즉, 자바스크립트에서는 원시값을 처리할 때 원시값을 래퍼객체로 자동 변환하며, 숫자는 Number객체 , 논리값은 Boolean 객체, 문자열은  String 객체로 변환된다.


#### 2.문자열을 배열로 읽고 쓰기

- 문자열을 읽을때는 charAt 메서드와 대괄호 연산자를 사용할 수 있다.

```js
let a = "abc";
a.charAt(1); //b
a[1] //b
```
★ 그러나 문자열의 인덱스를 가지고 값을 대입해서 수정할 수 없다. 해도 무시된다!
```js
a[1]='a'; //무시, a는 그대로
```


      💡NOTE
      유니코드 : 문자집합과 문자 인코딩 방식을 정한 표준 문자코드로, 전세계에서 사용하는 문자가 포함되어있다. 유니코드 문자 집합에서 각 문자의 위치를 '코드 포인트' 라고 부르며 코드 포인트에는 스칼라 값이라는 숫자가 할당되어있다. 


#### 3.논리연산자 관계연산자
(아는내용은 생략)
- 자바스크립트에서는 데이터의 값과 타입을 모두 비교할때 `===`를 쓴다고 했다.
그렇다면 동일연산자 ==와 일치연산자 === 의 작동 방식에 대해 알아보자.

 1. 동일연산자
 동일연산자는 좌변과 우변의 피연산자가 같은지를 판별하지만, 타입은 판별하지 않으므로 타입이 같을때와 타입이 다를때의 동작이 다르다.
  - 좌우 피연산자의 타입이 <mark>같을때</mark> : 같으면 true 다르면 false로 판정한다. 그러나 주의할 점은 *원시타입일때와 객체일때* 를 잘 구별 해야한다는 것이다. 자바스크립트는 원시타입을 제외한 모든값이 객체이다. 그리고 객체 타입 변수의 값은 *객체의 참조값* 이다. 

  - 좌우 피연산자의 타입이 <mark>다를때</mark> : **두 피연산자가 같은 타입이 되도록 변환**하여 비교한다.
    -  한쪽이 숫자고 다른 한쪽이 문자열이면, <span style=" text-decoration: underline;">문자열을 숫자로 변환</span>
    - undefined 와 null 은 같은것으로 한다.
    - 둘 중 한쪽이 논리값이면 true는 1, false는 0으로 변환하여 비교한다.
    - 한쪽이 객체로 다른 한쪽이 숫자 또는 문자열이면 객체를 toString이나 valueOf 메서르를 사용하여 원시타입으로 변환하여 비교한다.
    - 앞의 규칙에서 벗어나면 모두 '같지않음'으로 판정한다.

2. 일치연산자
`엄격한 비교!`  피연산자를 평가한 후에 타입을 변환하지 않은 상태의 두 값을 비교한다. 타입과 값이 모두 같아야 같다고 판정.
`NaN`은 모~~든값과 다 같지 않다고 판정한다. NaN === NaN 는 false다.

---

- 논리연산자 && || !

      연산자 우선순위는 정처기 하면서 증산시관비논삼대로 외웠는데, 중간중간 까먹지 않게 복습~ 이왕이면 외워두는게 좋지.
      <증감 산술 시프트 관계 비교 논리 삼항 대입>
  - 논리연산자의 피연산자는 논리값이 아니어도 된다. 필요에 따라 타입을 변환하기 때문이다. 0을 제외한 숫자, 빈문자열이 아닌 문자열, 모든 객체나 심벌은 `true`, 0,0-,빈문자열(""),NaN,null,undefined 는 `false`로 평가


- 💥 **논리곱 연산자(&&)와 논리합(||) 연산자는 단락평가를 한다**
  - 단락평가 : 첫번째 피연산자 값이 표현식을 결정하면 두번째 피연산자를 평가하지 않는것!! a&&b 를 했을때, a에서 false값이 나오면 b는 확인할 필요도 없이 false니까, b는 평가하지 않고 종료된다. 또한 true나 false를 반환하는 자바와 달리 **a자체의 값을 반환한다**. 만약 a를 평가한 값이 true 여서 b도 평가를 한다면, 표현식은 b의 값을 반환한다. 😅😅?
  
   - &&연산자의 이 특성은, 객체의 프로퍼티를 이용할 때와 객체가 null인지 아닌지 확인할때 유용하게 사용된다
 ```js
 let p = null;
 p&&p.name // 반환값 null // p가 이미 null->false이므로 우변은 평가하지 않고 p를 반환한다. false아니고 null이다!!!!

 p ={name:"jay",age:19}
 p&&p.name //반환값 : "jay" p -> 객체이므로 true, p.name은 jay 이므로 true 
 ```

  - 논리합연산자의 경우,  `a||b` 일때 a의 평가값이 true이면 b를 평가하지 않고도 true로 결정되기 때문에 b는 평가하지 않고 a를 반환하며 종료한다.
  - 이러한 특성으로, `||` 연산자는 여러개의 값 후보중에서 null 또는 undefined가 아닌 값을 선택하고자 할때 사용된다.   
  예를들어 
  ```js
  let time = time_interval || animationSettings.time || 33;

  // time_interval이 true이면, 즉 값이 정의되어 있으면 time에 time_interval을 대입하고 없다면 animationSetting.time으로 넘어가고, 또 없다면 33이 된다. 여러가지 후보를 만들수 있는 것이다.
  ```
  또한! 논리합 연산자는 함수에서 인수의 **초깃값**을 설정할 때 유용하게 사용할수 있다.

  ```js
  function f(x){
    x = x || 100;
  }

  //함수 f를 인수없이 f()로 호출하면 x에는 undefined가 들어간다. undefined는 false로 평가되므로 x = false || true의 꼴이 되고 결과적으로 100을 그대로 반환. x는 100이 대입된다.
  //즉! 인수가 있으면 인수 그대로 들어가고, 없으면 100으로 초기화 할 수 있는 것이다.(그러나 이렇게 사용하면 false로 평가되는 0이나 ""를 넘길수가 없다. false로 평가해서 100을 사용하게 되기 때문!!!!
  ```