# ✍️ What I learned Today ?

---
## ✨ Let's go 자바스크립트 ! 

### 002 객체와 배열, 함수의 기초

* Summary
1. 객체리터럴
2. 함수의 기초
3. 생성자
4. 내장객체
5. 배열

---

| 짚고 넘어가기 |

- 자바스트립트에는 자료형이 없다.
앞에서도 언급했지만, 자바스크립트에는 변수타입이 없으므로 변수에 모든 타입의 데이터를 저장할 수 있다고 했다. 
그렇구나~ 편하겠다~ 하고 넘어갔는데, function 작성할때 진짜로 변수명만 딱 써놓으니까 편하긴 편한데 허전한 느낌..

- 자바스크립트에서는 숫자를 모두 64비트 부동소수점으로 표현한다. 자바나 C언어에서는 double 타입에 속한다.
따라서 3/2 와 같은 연산을 하면 자바나 C언어처럼 몫만 표현되는 것이 아니라 1.5 그대로 나온다. 몫을 얻고싶을때는 Math.floor를 사용해서
직접 내림을 해줘야한다.

- 자바스크립트를 HTML 요소에 끼워넣을때는, HTML 요소에 큰따옴표를 사용하고 자바스크립트 요소는 작은따옴표를 사용하여 구분하는것이 좋다.

- undefined는 아직 값을 할당하지 않은 결과 / null은 아무것도 없음을 값으로 표현한 리터럴!

---

#### 1. 객체리터럴 
    자바 스크립트에서는 원시 타입을 제외한 모든 값이 객체이다.

- 자바스크립트에서 객체는 이름과 값을 한쌍으로 묶은 데이터 여러개를 모은것이다. 즉, 객체는 데이터 여러개를 하나로 모은 복합 데이터로 연관배열 또는 사전 이라고 부른다.

```js
let card = {suit:"하트",rank:"A"};

//card => 변수 | suit,rank => 프로퍼티 | "하트","A" => 리터럴

```

- 변수에 대입된 객체안의 프로퍼티 값을 읽거나 쓸 때에는
마침표(.) 연산자 또는 대괄호 연산자를 사용한다.

```js
//1번 : 미침표연산자 사용 - 문자열X, 프로퍼티 이름(식별자)만 이용
card.suit //"하트"
//2qjs : 대괄호 사용 - 문자열O
card["rank"] //"A"

```
##### 프로퍼티 추가 삭제
- 자바스크립트의 객체는 실행중에 프로퍼티를 자유롭게 추가,삭제 가능하다!

```js
//객체에 프로퍼티 추가
card.value = 14;
console.log(card); // Object {suit:"하트",rank:"A",value:14}

//객체에 프로퍼티 삭제
delete.card.value;
console.log(card); // Object {suit:"하트",rank:"A"}

```

##### in연산자
- 객체에 특정 프로퍼티가 있는지 확인할 때 사용하며 있으면 true 없으면 false를 반환한다.
```js
let card = {suit:"하트",rank:"A"};
console.log("color" in card); //false
console.log("suit" in card);  // true
```

    ※in 연산자가 조사하는 대상은, 객체가 가진 프로퍼티와 그 객체가 *상속*받은 모든 프로퍼티! 따라서 "toString"in card를 찍어보면 true가 반환된다. card가 Object객체를 상속받았기 때문이다.


---

#### 2. 함수의 기초

    자바스크립트에서의 함수 => 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 둔 것.

- 함수의 입력값 : 인수
- 출력값 : 반환값

**함수선언문**
```js
//함수 add1은 인수에 1을 더하여 반환하는 함수이다.
function add1(x){
  return x+1;
}
```

※ 가독성을 위해 함수이름은 동사 또는 동사로 시작하는 어휘로 만들며, 캐멀 표기법이나 밑줄표기법을 사용할 것

**함수 호출**
```js
let a = 3;
add1(a);
// 값의 전달 : add1함수가 호출될때, 변수 a의 복사본이 x에 할당된다. a와 x는 다른 영역의 메모리에 위치한 별개의 변수다. x값을 바꾸더라도 a값은 바뀌지 않는다.

function add1(p){
  p.x = p.x +1;
  p.y = p.y +1;
  return p;
}
let a = {x:3,y:4};
let b = add1(a);
//여기서는 add1에 원시값이 아니라 객체를 인수로 전달했다. 이 경우 변수 a를 전달함으로써 객체의 참조값을 넘겨준것이기 때문에 똑같은 객체를 참조한다. 따라서 add1(a)가 실행되어 p.x 와 p.y가 수정되면 a.x와 a.y도 수정되는 것과 같다.
```

**인수를 우아하게 전달하기**
함수에 넘겨야 하는 인수 개수가 많아지면 
- 인수의 순서를 착각하기 쉽고
- 함수가 받는 인수 개수를 바꾸면 함수의 호출 방법이 바뀌므로 프로그램 전체를 수정해야한다.

따라서, 인수를 객체의 프로퍼티에 담아서 넘기면 간단히 해결가능하다.

```js
//그냥 넘기기
function alpha(a,b,c,d,e,f,g){}
alpha(1,2,3,4,5,6,7)
// 객체의 프로퍼티에 담아서 넘기기
let parameters={
  a:1
  b:2
  c:3
  d:4
  e:5
  f:6
}
alpha(parameters);
//단, 함수안에서 객체의 프로퍼티를 수정하면 호출한 코드에 있는 인수 객체의 프로퍼티도 함께 바뀌므로 주의. 이유는 위에서 설명(참조전달)
```
**함수실행 흐름**
1. 호출한 코드에 있는 인수가 함수 정의분의 인자에 대입
2. 함수정의문의 중괄호 안에 작성된 프로그램이 순차로 진행
3. return문이 실행되면 호출한 코드로 되돌아가며, return 문의 값이 반환값이 된다.
4. return문이 실행되지 않은 상태로 마지막 문장이 실행되면 호출한 코드로 되돌아간 후에 undefined가 함수 반환값이 된다.


**함수 리터럴로 함수 정의하기**
- 함수는 함수선언문 뿐만 아니라 함수 리터럴로도 정의할 수 있다.
- A.K.A 익명함수 , 무명함수

```js
let square = function(x){return x*x};
square(2); //함수 실행 
//함수에 이름이 없다.
//함수선언문에서는 끝에 세미콜론을 안붙여도 되지만, 함수 리터럴로 사용할때는 반드시 세미콜론 붙여야함.
```
- 함수선언문 VS 함수리터럴 : 
자바스크립트 엔진이 함수선언문으로 정의한 함수는 호이스팅하지만 함수 리터럴로 정의한 함수는 끌어올리지 않는다. 즉, 함수리터럴로 정의한 익명함수는 변수에 할당한 후에야 어떠한 이름을 갖게되고 그 변수이름으로 호출할 수 있다.

**객체의 메서드**

      객체의 프로퍼티 중에서 함수 객체의 참조를 값으로 담고있는 프로퍼티를 가르켜 메서드 라고 부른다.

```js
// circle 객체
let circle ={
  center: {x:1.0, y:2.0}; //원의 중점을 표현하는 객체
  radius : 2.5 ; // 원의 반지름 프로퍼티
  area : function(){
    return Math.PI * this.radius * this.radius;
  } //원의 넓이를 구하는 메서드, 함수객체 안에 적힌 this는 그 함수를 메서드로 가지고 있는 객체를 가르킨다. 여기선 circle을 가르키겠지?~
}
```


      💡 C++나 Java 등의 객체지향 언어에서는 객체안의 데이터와 메서드를 별개로 다룬다. 하지만 자바스크립트에서 메서드는 함수를 값으로 가진 프로퍼티다. 따라서 '기본적으로' 자바스크립트에서 프로퍼티는 객체 내부의 데이터와 메서드 모두를 뜻한다. 그러나 상황에 따라서는 프로퍼티와 메서드 등으로 구분해서 설명해야 할 때가 있다. 이때 프로퍼티는 함수를 값으로 가지고 있지 않은 프로퍼티를 뜻하며, 메서드는 함수를 값으로 가진 프로퍼티를 뜻한다.


---

  #### 3. 생성자 
        자바스크립트에는 처음부터 사용할 수 있는 내장객체가 마련되어 있다.

💡 
Java와 C++등은 같은 프로퍼티를 같은 객체를 여러개 생성하는 수단으로 클래스를 사용한다. 클래스는 흔히, 붕어빵을 찍어내는 빵틀 같은 개념이라고 표현되는데, 자바스크립트에는 클래스 개념이 없다. 대신 생성자 라고 하는 함수로 똑같은 구조의 객체를 생성 할 수 있다. 

자바에서 클래스는 사용자타입 자료형이라고 하기도 하는데, 이는 자료형을 내가 원하는 구조로 만들어서 똑가튼 '타입'의 객체를 생성해내기 때문이다. 그리고 생성자로 객체를 만들어내는건 똑같으나, 자바에서의 생성자는 클래스 안에 존재하며 클래스 이름과 똑같은 이름을 가지는 특수한 메서드이다.

 **그러나!!!!**
자바스크립트에서의 생성자는 그냥 함수다. 그리고 생성자 이름은 관례적으로 파스칼 표기법을 사용한다(첫글자를 대문자로 쓰는 표기법)
```js
function Americano(water,espresso){  // 생성자
  this.water = water;
  this.espresso = espresso;
}

let ame = new Americano("보통",1); //생성자의 인스턴스
let ame2 = new Americano("조금",3);

```
         
         

        
 
- 내장 생성자
  |생성자 |생성되는 객체 |
  |---|---|
  |Object | 일반객체 |
  |String|문자열객체|
  |Number|숫자객체|
  |Boolean|논리값 객체|
  |Array|배열|
  |Date|날짜와 시간을 다루는 객체|
  |Function|함수객체|
  |RegExp|정규 표현식 객체|
  |Error|오류객체
  |EvalError| eval() 함수와 관련된 오류를 표현하는 객체
  |InternalError|자바스크립트 내부에서 밠행한 오류를 표현하는 객체|
  |RangeError| 값이 허용범위를 넘었을때 발생산 오류를 표현하는 객체|
  |ReferenceError|없는 변수를 참조할때 발생한 오류를 표현하는 객체|
  |SyntaxError| 문법이 어긋날 때 발생한 오류를 표현하는 객체|
  |TypeError| 값이 기대한 타입이 아닐때 발생한 오류를 표현하는 객체|
  |URIError| 잘못된 URI를 만났을때 발생한 오류를 표현하는 객체|
  |ECMAScript6에서 추가 | ▽
  |Symbol| 심벌을 생성|
  |Int8Array8| 부호가 있는 8비트 정수 배열을 생성|
  |Unit8Array8| 부호가 없는 8비트 정수 배열을 생성|
  |Int16Array8| 부호가 있는 16비트 정수 배열을 생성|
  |Unit16Array8| 부호가 없는 16비트 정수 배열을 생성|
  |Int32Array8| 부호가 있는 32비트 정수 배열을 생성|
  |Unit32Array8| 부호가 없는 32비트 정수 배열을 생성|
  |Float32Array32| 32비트 부동소수점 배열 생성|
  |Float64Array32| 64비트 부동소수점 배열 생성|
  |ArrayBuffer| 고정길이 이진 데이터 버퍼 생성|
  |DataView| ArrayBuffer 데이터를 읽고 슬쑤 있는 수단 제공|
  |Promise| 처리지연 및 비동기 처리를 관리하는 수단 제공|
  |Generator| 제너레이터 함수를 다룰수 있는 수단 제공|
  |GeneratorFunction| 제너레이터 함수를 생성|
  |Proxy | 객체의 기본적인 동작을 재정의하는 기능을 제공|
  |Map| key/value 맵 생성|
  |Set| 중복을 허용하지 않는 데이터 집합 생성|
  |WeakMap| 약한 참조를 유지하는 key/value맵 생성|
  |weakSwt| 약한 참조를 유지하는 고유한 데이터집합 생성|
  

 **<대표적인 내장생성자>**
 - Date : 날짜와 시간을 표현하는 객체 생성, 날짜와 시간처리를 간단하게 할수있다.
 ```js
 let now = new Date(); //실행한 시점의 날짜와 시간 정보를 담은 객체 생성
 console.log(now); // Date {Tue Mar 02 2023 10:30:55 GMT+0900 (KST)}
 
 let then = new Date(2016,2,10);
 console.log(then); // Date {Wed Feb 10 2016 00:00:00 GMT+0900 (KST)}
  
 ```

- Date 객체는 계산식 안에서 밀리초 단위 정수로 값의 타입이 바뀐다. 이 성질을 활용하여 프로그램 실행에 걸리는 시간을 밀리초 단위로 구할 수 있다

```js
let start = new Date();
 //실행코드
let end = new Date();
let elapsed = end - start; //프로그램 실행에 걸리는 시간
```
