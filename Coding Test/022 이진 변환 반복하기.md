## 이진변환 반복하기 LV.2
### 0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다. x의 모든 0을 제거합니다. x의 길이를 c라고 하면, x를 "c를 2진법으로 표현한 문자열"로 바꿉니다. 예를 들어, x = "0111010"이라면, x에 이진 변환을 가하면 x = "0111010" -> "1111" -> "100" 이 됩니다. 0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 "1"이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.


- 제한사항
- s의 길이는 1 이상 150,000 이하입니다.
- s에는 '1'이 최소 하나 이상 포함되어 있습니다.

--- 
내 풀이 
```js
function solution(s) { 
    var answer = [];
    let zero = 0; 
    let cnt = 0;

    
    while(s !== '1'){
     let target = s.replaceAll(0,''); 
     zero += s.length - target.length ;
     s = target.length.toString(2);  
     cnt ++; 
    }
    
    answer.push(cnt,zero);  
    return answer;
}

```

#### 💡 풀이 설명 :  
1. 먼저, 반복할 횟수를 모르고 어느 지점까지 반복을 해야하므로 while문으로 s가 1이 될때까지 반복하라는 제약조건을 줬다.
2. 제거된 0 의 개수를 알아야 하기때문에 문자열 s를 target 변수에 복사해서 s의 문자열 길이에서 target의 길이를 뺄셈하여 변수 zero에 넣어줬다.
3. s에서 0을 제거한 결과값인 target 의 길이를, toString(2) 를 통해 2진수로 변환하여 다시 s에 대입
4. 로직이 끝날때 마다 cnt 증가, 블록문이 끝난 시점에서 s는 결국 0을 제거하고, 그 길이를 2진수로 변환한 값이 되고 그 값이 1이 아니면 다시 루프!
5. 루프 종료 후 배열 answer에 cnt와 zero를 푸시.


로직은 금방 생각해냈는데 while문이 작동이 제대로 되지않아서 푸는데 시간이 좀 걸렸다.
이유는.. `while(s!== 1)` 로 작성했었는데, s는 문자열임을 간과하고 1을 넘버타입으로 비교했기 때문에 false값으로 작동했기 때문이였다.
해결방법은 두가지, 
` while(s !== '1')` 문자리터럴로 비교해주거나
` while( s != 1)` 데이터 타입을 비교하지 않는 법!
테스트해보니 문자열로 비교해주는게 런타임이 약간 더 짧았다.

